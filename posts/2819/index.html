<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="尝试用 three.js 实现了这个跨窗口的粒子动画"><meta name="keywords" content=""><meta name="author" content="alphardex"><meta name="copyright" content="alphardex"><title>尝试用 three.js 实现了这个跨窗口的粒子动画 | 名無声</title><link rel="shortcut icon" href="/mygo/img/favicon.ico"><link rel="stylesheet" href="/mygo/css/index.css?version=1.9.1"><link rel="stylesheet" href="/mygo/css/mygo.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/mygo/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '7.2.0'
} </script><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/mygo/atom.xml" title="名無声" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#GPGPU"><span class="toc-number">1.</span> <span class="toc-text">GPGPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Compute-Shader"><span class="toc-number">2.</span> <span class="toc-text">Compute Shader</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-number">3.</span> <span class="toc-text">最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">源码</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://s2.loli.net/2024/05/21/NhyV4THWaAgOwED.jpg"></div><div class="author-info__name text-center">alphardex</div><div class="author-info__description text-center">&quot;普通&quot;とか&quot;あたりまえ&quot;ってなんだろう</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/mygo/archives"><span class="pull-left">Articles</span><span class="pull-right">45</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://s2.loli.net/2024/05/21/HtNjkzv1FEdAVby.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/mygo/">名無声</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/mygo/">Home</a><a class="site-page" href="/mygo/archives">Archives</a><a class="site-page" href="/mygo/about">About</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">尝试用 three.js 实现了这个跨窗口的粒子动画</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-11-27</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>相信不久前大家已经被这个粒子动画给刷屏了吧：</p>
<p><img src="https://s2.loli.net/2023/11/27/uvFLrXDKYHa1Ppl.png" alt="bcab9963-4461-4964-96a0-214a15626f75"></p>
<p>之前看过很多人都在分析跟这个效果相关的跨窗口通信技术，尽管这样是挺好，但我依旧有点纳闷：为什么没有人讲讲背后的粒子特效是怎么实现的呢？</p>
<p>于是乎，我花了一整个周末，把这个粒子特效给肝了出来。尽管可能跟原特效相比有一点差距，但也表明了这种效果是可以实现的。</p>
<p><img src="https://s2.loli.net/2023/11/27/KqNm5ITYWidblpH.gif" alt="entangled"></p>
<p>在线体验：<a target="_blank" rel="noopener" href="https://entangled-fxhash.netlify.app/">https://entangled-fxhash.netlify.app/</a></p>
<p>本文就让我们来看看实现这个粒子特效有哪些要点吧~</p>
<span id="more"></span>

<h2 id="GPGPU"><a href="#GPGPU" class="headerlink" title="GPGPU"></a>GPGPU</h2><p>当我第一眼看到原特效时，发现那个球体是由大量的粒子组成的，第一反应就是<code>THREE.Points</code>，但是又转念一想，光这个是不够的，因为在粒子量足够大的情况下，同时渲染大量的运动粒子肯定会遇到性能上的瓶颈。</p>
<p>然后，我又想到了另一个技术——<code>GPGPU</code>，中文翻译是“图形处理器通用计算”，尽管这个概念看上去很复杂，但其实也很简单——利用<code>GPU</code>的并行特性来执行一些和图形渲染无关的计算任务，如模拟粒子系统等。在粒子非常多的情况下，用它就能满足性能上的需求。</p>
<p><code>three.js</code>的官方文档上有一个<a target="_blank" rel="noopener" href="https://threejs.org/examples/#webgl_gpgpu_birds">模拟鸟群飞行的效果</a>，就用到了这个技术，可以把鸟群飞行看作是一个不断运动着的粒子系统。</p>
<p><img src="https://s2.loli.net/2023/11/27/v675RSzB8lYCnFs.png" alt="4307749b-15a0-47a4-b562-e34f27212e68"></p>
<p>那么如何使用<code>GPGPU</code>呢？大致步骤如下：</p>
<ol>
<li>创建<code>GPGPU</code>对象，<code>three.js</code>里是<code>GPUComputationRenderer</code>；</li>
<li>创建数据纹理，用来存储需要<code>GPU</code>计算的数据；</li>
<li>创建<code>GPGPU</code>变量，每个变量需要一个对应的<code>Compute Shader</code>（计算着色器），用来处理变量的计算逻辑；</li>
<li>初始化<code>GPGPU</code>，并在渲染循环中使其不断计算，将<code>GPGPU</code>变量计算得来的结果作为纹理变量赋给需要的材质。</li>
</ol>
<p>以下是我的粒子效果用到的相关代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> width = <span class="number">512</span>;</span><br><span class="line"><span class="keyword">const</span> size = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> count = width ** <span class="number">2</span>; <span class="comment">// 我们总共要实时计算 512x512=262144 个粒子！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建GPGPU对象(kokomi.GPUComputer 是一个对 GPUComputationRenderer 的封装)</span></span><br><span class="line"><span class="keyword">const</span> gpgpu = <span class="keyword">new</span> kokomi.<span class="title class_">GPUComputer</span>(<span class="variable language_">this</span>.<span class="property">base</span>, &#123;</span><br><span class="line">  width,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 创建数据纹理</span></span><br><span class="line"><span class="keyword">const</span> posDt = gpgpu.<span class="title function_">createTexture</span>();</span><br><span class="line"><span class="keyword">const</span> data = posDt.<span class="property">image</span>.<span class="property">data</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为数据纹理填充随机数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; data.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  data[i * <span class="number">4</span> + <span class="number">0</span>] = <span class="variable constant_">THREE</span>.<span class="property">MathUtils</span>.<span class="title function_">randFloatSpread</span>(size);</span><br><span class="line">  data[i * <span class="number">4</span> + <span class="number">1</span>] = <span class="variable constant_">THREE</span>.<span class="property">MathUtils</span>.<span class="title function_">randFloatSpread</span>(size);</span><br><span class="line">  data[i * <span class="number">4</span> + <span class="number">2</span>] = <span class="variable constant_">THREE</span>.<span class="property">MathUtils</span>.<span class="title function_">randFloatSpread</span>(size);</span><br><span class="line">  data[i * <span class="number">4</span> + <span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建GPGPU变量</span></span><br><span class="line"><span class="keyword">const</span> posVar = gpgpu.<span class="title function_">createVariable</span>(</span><br><span class="line">  <span class="string">&quot;texturePosition&quot;</span>,</span><br><span class="line">  testObjectComputeShader,</span><br><span class="line">  posDt,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">uFreq</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化GPGPU</span></span><br><span class="line">gpgpu.<span class="title function_">init</span>();</span><br></pre></td></tr></table></figure>

<p>粒子的本体还是用<code>THREE.Points</code>，只不过<code>geometry</code>用的是自定义的<code>BufferGeometry</code>，里面可以填充一些随机的位置数据<code>position</code>，同时也要加上用来采样<code>GPGPU</code>纹理的<code>UV</code>坐标<code>reference</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>();</span><br><span class="line"><span class="keyword">const</span> positions = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(count * <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> references = <span class="keyword">new</span> <span class="title class_">Float32Array</span>(count * <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; width; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; width; j++) &#123;</span><br><span class="line">    <span class="keyword">const</span> idx = i + j * width;</span><br><span class="line">    positions[idx * <span class="number">3</span> + <span class="number">0</span>] = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">    positions[idx * <span class="number">3</span> + <span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">    positions[idx * <span class="number">3</span> + <span class="number">2</span>] = <span class="title class_">Math</span>.<span class="title function_">random</span>();</span><br><span class="line">    references[idx * <span class="number">2</span> + <span class="number">0</span>] = i / width;</span><br><span class="line">    references[idx * <span class="number">2</span> + <span class="number">1</span>] = j / width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">geometry.<span class="title function_">setAttribute</span>(<span class="string">&quot;position&quot;</span>, <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(positions, <span class="number">3</span>));</span><br><span class="line">geometry.<span class="title function_">setAttribute</span>(<span class="string">&quot;reference&quot;</span>, <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(references, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>

<p>材质的话就用自定义着色器材质<code>ShaderMaterial</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">ShaderMaterial</span>(&#123;</span><br><span class="line">  <span class="attr">vertexShader</span>: testObjectVertexShader,</span><br><span class="line">  <span class="attr">fragmentShader</span>: testObjectFragmentShader,</span><br><span class="line">  <span class="attr">uniforms</span>: &#123;</span><br><span class="line">    <span class="attr">texturePosition</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">uPointSize</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">uPixelRatio</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">base</span>.<span class="property">renderer</span>.<span class="title function_">getPixelRatio</span>(),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">transparent</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">blending</span>: <span class="variable constant_">THREE</span>.<span class="property">AdditiveBlending</span>,</span><br><span class="line">  <span class="attr">depthWrite</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>顶点着色器中，我们要采样<code>GPGPU</code>帮我们计算得来的粒子位置。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> uPointSize;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> uPixelRatio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texturePosition;</span><br><span class="line"></span><br><span class="line"><span class="keyword">attribute</span> <span class="type">vec2</span> reference;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec3</span> p=<span class="built_in">texture</span>(texturePosition,reference).xyz;</span><br><span class="line">    <span class="built_in">gl_Position</span>=projectionMatrix*modelViewMatrix*<span class="type">vec4</span>(p,<span class="number">1.</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_PointSize</span>=uPointSize*uPixelRatio;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>片元着色器直接输出粒子的颜色即可。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec4</span> col=<span class="type">vec4</span>(<span class="number">0.</span>,<span class="number">1.</span>,<span class="number">0.</span>,<span class="number">1.</span>);</span><br><span class="line">    <span class="built_in">gl_FragColor</span>=col;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是创建微粒对象，并将它放到场景中，在渲染循环中给它的材质注入<code>GPGPU</code>计算得来的纹理数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> points = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Points</span>(geometry, material);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">scene</span>.<span class="title function_">add</span>(points);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">update</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> mat = points.<span class="property">material</span>;</span><br><span class="line">  mat.<span class="property">uniforms</span>.<span class="property">texturePosition</span>.<span class="property">value</span> = gpgpu.<span class="title function_">getVariableRt</span>(posVar);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>准备工作都已到位，接下来让我们开始进入真正的重头戏——<code>Compute Shader</code>。</p>
<h2 id="Compute-Shader"><a href="#Compute-Shader" class="headerlink" title="Compute Shader"></a>Compute Shader</h2><p>计算着色器的格式跟片元着色器类似，都是输出<code>gl_FragColor</code>，只不过这里的<code>color</code>代表的是<code>GPU</code>变量的值，在这里，我们用<code>texturePosition</code>作为了<code>GPU</code>变量，也就是粒子的位置，在着色器顶部声明好它。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> texturePosition;</span><br></pre></td></tr></table></figure>

<p>在主函数中，我们计算好<code>UV</code>坐标，并用它来采样<code>texturePosition</code>纹理。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec2</span> uv=<span class="built_in">gl_FragCoord</span>.xy/resolution.xy;</span><br><span class="line">    <span class="type">vec3</span> pos=<span class="built_in">texture</span>(texturePosition,uv).xyz;</span><br><span class="line">    <span class="built_in">gl_FragColor</span>=<span class="type">vec4</span>(pos,<span class="number">1.</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/27/1E5HF7I9KyUqvPD.png" alt="dea09304-70bd-4a36-befa-ebdeb15baf4b"></p>
<p>这里我们直接输出了位置纹理的原始数据，可以看到就是一堆随机的离散点。</p>
<p>是时候让这些点动起来了！给位置变量<code>pos</code>应用噪声函数吧，我选择了卷曲噪声<code>curl</code>。</p>
<blockquote>
<p>这里用到了<code>Shader</code>函数库<a target="_blank" rel="noopener" href="https://github.com/patriciogonzalezvivo/lygia/">lygia</a>，里面有很多实用的噪声函数。</p>
</blockquote>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;/node_modules/lygia/generative/curl.glsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec2</span> uv=<span class="built_in">gl_FragCoord</span>.xy/resolution.xy;</span><br><span class="line">    <span class="type">vec3</span> pos=<span class="built_in">texture</span>(texturePosition,uv).xyz;</span><br><span class="line">    pos=curl(pos);</span><br><span class="line">    <span class="built_in">gl_FragColor</span>=<span class="type">vec4</span>(pos,<span class="number">1.</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/27/SGrKLsNT7lBHg9z.png" alt="a9082480-2048-4d84-a280-9dbdf34cf7d3"></p>
<p>之前离散的点立马就变成了一个美丽的噪声球体。</p>
<p>除了单个卷曲噪声外，我们还可以用<code>fbm</code>，产生一个更加混沌的结果。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> fbm(<span class="type">vec3</span> p)&#123;</span><br><span class="line">    <span class="type">vec3</span> value=p;</span><br><span class="line">    <span class="type">float</span> amplitude=<span class="number">.5</span>;</span><br><span class="line">    <span class="type">float</span> frequency=<span class="number">2.</span>;</span><br><span class="line">    <span class="type">float</span> lacunarity=<span class="number">2.</span>;</span><br><span class="line">    <span class="type">float</span> persistance=<span class="number">.5</span>;</span><br><span class="line">    <span class="type">float</span> scale=<span class="number">.5</span>;</span><br><span class="line">    <span class="type">int</span> octaves=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;octaves;i++)&#123;</span><br><span class="line">        <span class="type">vec3</span> noiseVal=curl(value*frequency*scale);</span><br><span class="line"></span><br><span class="line">        value+=amplitude*noiseVal;</span><br><span class="line">        frequency*=lacunarity;</span><br><span class="line">        amplitude*=persistance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec2</span> uv=<span class="built_in">gl_FragCoord</span>.xy/resolution.xy;</span><br><span class="line">    <span class="type">vec3</span> pos=<span class="built_in">texture</span>(texturePosition,uv).xyz;</span><br><span class="line">    pos=curl(pos*uFreq);</span><br><span class="line">    pos=fbm(pos);</span><br><span class="line">    <span class="built_in">gl_FragColor</span>=<span class="type">vec4</span>(pos,<span class="number">1.</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/28/HdaEUyvsMhX8wxI.png" alt="b096ebdf-1f0f-4e78-819d-896dfedc5a10"></p>
<p>但这个结果太混沌了，跟之前的球体相差有点大。我们可以用<code>mix</code>函数来将它和球体有机地混合起来，混合因子也可以用其他的噪声函数来计算。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec2</span> uv=<span class="built_in">gl_FragCoord</span>.xy/resolution.xy;</span><br><span class="line">    <span class="type">vec3</span> col=<span class="type">vec3</span>(<span class="number">0.</span>);</span><br><span class="line">    <span class="type">vec3</span> pos=<span class="built_in">texture</span>(texturePosition,uv).xyz;</span><br><span class="line">    pos=curl(pos*uFreq);</span><br><span class="line">    col=pos;</span><br><span class="line">    <span class="type">vec3</span> pos2=<span class="built_in">texture</span>(texturePosition,uv).xyz;</span><br><span class="line">    pos2=curl(pos2*uFreq);</span><br><span class="line">    pos2=fbm(pos2);</span><br><span class="line">    col=pos2;</span><br><span class="line">    <span class="type">float</span> mixFactor=<span class="number">0.</span>;</span><br><span class="line">    mixFactor=cnoise(pos+iTime)*<span class="number">.5</span>;</span><br><span class="line">    col=<span class="built_in">mix</span>(pos,pos2,mixFactor);</span><br><span class="line">    <span class="built_in">gl_FragColor</span>=<span class="type">vec4</span>(col,<span class="number">1.</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/27/TPxjFsiYdER1w8L.gif" alt="fd7f556a-3652-d64f-3b53-a4d3708e9b58_(1)"></p>
<p>此外，我们可以做一个拉伸球的动画，用作后面纠缠动画的基础，思路如下：定义一个牵引点，用<code>sdf</code>函数算出牵引距离，再求得牵引方向向量，给位置变量应用它们的乘积即可。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &quot;/node_modules/lygia/sdf/boxSDF.glsl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec2</span> uv=<span class="built_in">gl_FragCoord</span>.xy/resolution.xy;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> attract=uAttract;</span><br><span class="line">    <span class="type">float</span> attractX=<span class="built_in">abs</span>(attract.x);</span><br><span class="line">    <span class="type">float</span> d=boxSDF(col-attract,<span class="type">vec3</span>(attractX,<span class="number">.25</span>,<span class="number">.25</span>));</span><br><span class="line">    <span class="type">vec3</span> dir=<span class="built_in">normalize</span>(col-attract);</span><br><span class="line">    col-=dir*<span class="built_in">smoothstep</span>(<span class="number">.2</span>,<span class="number">.0</span>,d)*(attractX<span class="number">-1.</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span>=<span class="type">vec4</span>(col,<span class="number">1.</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/11/27/NDxVZtEcwkzean4.gif" alt="Shader项目模板_(1)"></p>
<p>至于两球相互纠缠，emmmm，说实话我直接用了原作者<a target="_blank" rel="noopener" href="https://github.com/bgstaal/multipleWindow3dScene">开源的项目</a>里的<code>WindowManager</code>来实现的，把里面的方块替换成了我的粒子球体，最终结果就是文章开头的那个动画。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>粒子效果本身差不多就这样完成了。还有一些待优化的点：</p>
<ol>
<li>不用卷曲噪声“逃课”，用更加精美的扭曲方式来美化球体。</li>
<li>纠缠动画有一点生硬，并不像原效果那样丝滑、连贯。</li>
</ol>
<p>主要还是第 2 点吧，感觉原作者是用了一种特定的算法来实现的，只可惜我不会 QAQ，还得继续努力呢~</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>Github：<a target="_blank" rel="noopener" href="https://github.com/alphardex/entangled">https://github.com/alphardex/entangled</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">alphardex</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://alphardex.github.io/mygo/posts/2819/">https://alphardex.github.io/mygo/posts/2819/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/mygo/posts/57476/"><i class="fa fa-chevron-left">  </i><span>一个普通魔法使的 2023 年终总结</span></a></div><div class="next-post pull-right"><a href="/mygo/posts/10700/"><span>原神，启动！three.js 复刻原神登录界面技术浅析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = 'false' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'MUKqiaU6CnxOn2VeT4cUBLdG-gzGzoHsz',
  appKey:'nxePlNHUgdOaABmHUoWz4TpR',
  placeholder:'何が言いたいことがある？',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(https://s2.loli.net/2024/05/21/HtNjkzv1FEdAVby.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2024 By alphardex</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/mygo/js/utils.js?version=1.9.1"></script><script src="/mygo/js/fancybox.js?version=1.9.1"></script><script src="/mygo/js/sidebar.js?version=1.9.1"></script><script src="/mygo/js/copy.js?version=1.9.1"></script><script src="/mygo/js/fireworks.js?version=1.9.1"></script><script src="/mygo/js/transition.js?version=1.9.1"></script><script src="/mygo/js/scroll.js?version=1.9.1"></script><script src="/mygo/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>